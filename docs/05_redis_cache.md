# 캐시란 무엇인가?

캐시(Cache)란 자주 사용되는 데이터를 임시로 저장하여 보다 빠르게 액세스할 수 있도록 하는 메커니즘이다. 캐싱을 활용하면 데이터 접근 속도를 향상시키고 시스템의 부하를 줄일 수 있다. 캐시는 다양한 형태로 존재하며, 주요 사례는 다음과 같다.

## 1. DNS 캐시
DNS 캐시는 도메인 네임 시스템(DNS) 요청 결과를 저장하여 동일한 도메인에 대한 반복적인 조회 시 더 빠르게 응답할 수 있도록 한다. 클라이언트, 운영 체제, 브라우저, ISP 등의 여러 계층에서 캐싱이 이루어진다.

## 2. CPU 캐시
CPU 캐시는 프로세서 내부 또는 근처에 위치한 초고속 메모리로, 반복적인 데이터 및 명령어를 저장하여 성능을 향상시킨다. L1, L2, L3 캐시가 존재하며, 가까울수록 빠른 속도를 제공한다.

## 3. CDN 캐시
콘텐츠 전송 네트워크(Content Delivery Network, CDN) 캐시는 글로벌 네트워크에 분산된 서버에 정적 콘텐츠(예: 이미지, 동영상, CSS, JavaScript)를 저장하여 사용자와 가까운 위치에서 데이터를 제공함으로써 로딩 속도를 최적화한다.

## 4. 서버 내 메모리 캐시와 외부 캐시 서비스 비교
- **서버 내 메모리 캐시**: 웹 애플리케이션 내에서 운영되는 메모리 캐시(예: 로컬 변수, 객체 캐싱, Spring Cache 등)로 빠른 속도를 제공하지만, 서버 재시작 시 데이터가 소멸한다.
- **외부 캐시 서비스**: Redis, Memcached, CDN 등 별도의 캐싱 시스템을 활용하여 데이터를 저장하고 관리하며, 확장성이 뛰어나다.

---

# 캐시 전략 4가지

1. **Read-Through**
    - 캐시 조회 시 데이터가 없으면 자동으로 원본 데이터베이스에서 데이터를 가져와 캐시에 저장한 후 반환하는 방식
    - 일관된 캐싱을 보장하며 데이터 최신성이 보장된다.

2. **Write-Through**
    - 데이터를 캐시에 저장할 때 동시에 데이터베이스에도 반영하는 방식
    - 데이터 일관성이 유지되지만, 쓰기 성능이 낮을 수 있다.

3. **Write-Behind (Write-Back)**
    - 캐시에 먼저 데이터를 저장한 후 일정 시간이 지난 후 또는 특정 조건이 만족되면 데이터베이스에 반영하는 방식
    - 데이터베이스 부하를 줄일 수 있지만, 데이터 유실 가능성이 있다.

4. **Cache-Aside (Lazy Loading)**
    - 애플리케이션이 직접 캐시를 조회하고, 데이터가 없을 경우 데이터베이스에서 가져와 캐시에 저장하는 방식
    - 유연성이 높지만 캐시 미스(Cache Miss) 시 성능 저하가 발생할 수 있다.

---

# 캐시 스탬피드 현상

캐시 스탬피드(Cache Stampede)는 특정 데이터가 만료될 때 다수의 요청이 동시에 캐시 미스로 인해 원본 데이터베이스로 몰려 과부하가 발생하는 현상이다. 이를 방지하기 위한 전략은 다음과 같다.

- **TTL(Time To Live) 분산**: 캐시 만료 시간을 랜덤하게 설정하여 동시 만료를 방지한다.
- **백그라운드 리프레시**: 캐시 만료 전에 백그라운드에서 주기적으로 데이터를 갱신한다.
- **Mutex Locking**: 하나의 요청만 데이터베이스에서 데이터를 가져오도록 락을 설정하여 다수의 요청이 몰리는 것을 방지한다.
- **PER (Probabilistic Early Refresh) 알고리즘**: 캐시 만료 전에 확률적으로 일부 요청이 먼저 새로운 데이터를 갱신하도록 하여, 특정 순간에 모든 요청이 한꺼번에 몰리는 현상을 줄인다.

---

# 조회 API의 적절한 캐싱 방법

## 1. 상품 목록 조회 API (GET /api/v1/products/list)
- 페이지네이션이 되어 있지만, 대량의 데이터를 자주 조회할 경우 DB 부하가 발생할 수 있다.
- 상품 목록은 비교적 변경 빈도가 낮아 캐싱을 적용할 수 있다.

### 캐싱 전략
- **Cache-Aside**: 캐시에서 먼저 조회하고, 없을 경우 데이터베이스에서 가져와 캐시에 저장한다.

#### **선택 이유**
- 상품 목록은 자주 변경되지 않으며, 특정 사용자가 새로운 데이터를 즉시 확인해야 할 필요성이 낮다.
- Cache-Aside 방식은 유연성이 높아, 필요할 때만 캐시에 데이터를 저장하고 일정 시간이 지나면 자동으로 만료되므로 관리가 용이하다.
- 캐시 미스(Cache Miss) 시에는 DB에서 데이터를 조회하지만, 이후 캐시에 저장되므로 동일한 요청이 반복될 경우 성능을 향상시킬 수 있다.

## 2. 상위 주문 상품 조회 API (GET /api/v1/products/top)
- 최근 3일간 데이터를 기반으로 하므로 매번 DB를 조회하면 부담이 발생한다.
- 자주 조회되지만, 실시간 반영이 필요하지 않다.

### 캐싱 전략
- **Write-Behind (Write-Back)**: 일정 주기(예: 하루 1번)마다 인기 상품 데이터를 갱신하여 Redis에 저장한다.

#### **선택 이유**
- 상위 주문 상품 정보는 실시간성이 필요하지 않고, 일정 간격으로 갱신되더라도 비즈니스 요구사항을 만족할 수 있다.
- Write-Behind 방식은 비동기적으로 데이터를 갱신하므로 DB 부하를 줄이면서 최신 데이터를 유지할 수 있다.
- 캐시 만료 시 여러 요청이 동시에 DB를 조회하는 캐시 스탬피드(Cache Stampede) 문제를 방지할 수 있으며, 미리 갱신된 데이터를 제공하여 빠른 응답 속도를 유지할 수 있다.

---

# 결론
캐싱을 효과적으로 적용하면 성능을 향상시키고 시스템 부하를 줄일 수 있다. 조회 API별 특성에 맞는 캐싱 전략을 선택하여 최적의 성능을 보장하는 것이 중요하다. Redis와 같은 외부 캐시를 적극 활용하고, TTL과 백그라운드 갱신을 적절히 조합하여 캐시 스탬피드를 방지하는 것이 핵심 전략이다.

